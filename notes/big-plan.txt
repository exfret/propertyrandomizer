Roughly 1-hour chunks at deepest level

Critical bugfixes as needed (1hr for following - complete ASAP except for Nifyr needed ones)
    1. Mining drill offsets inside machines
    2. Asteroid resistances softlock
    3. Manual compat connection for solar panels before space

I. ALGORITHM: Unified randomization (Most of January)
    A. First pass sort
        1. Block sort
            i. Outline approach, vars needed, helper functions
            ii. Initial implementation without new_conn
            iii. Claude review/testing
            iv. Adding new_conn and second round review/testing
        2. Context extension
            i. Adding new contexts to logic, planning functions/vars for context top sort
            ii. Implementation
            iii. Review
            iv. Combined block and context extension sort and review
        3. Order finding pass
            i. Review notes, plan out details of approach, like what pools should be restricted
            ii. Use item rando slot/traveler approach, tracking restricted prereq pools (no special surface intermediates tracking), booting if needed for prereq pool
    B. Unified prereq shuffle
        1. Gathering randomizations
            i. Make list of randomizations to use, edges, etc.
            ii. Implement preprocessing and spoofing for each
            iii. Implement claiming and plan validations needed, start validation coding
            iv. Implement rest of validations
        2. Finishing off execute
            i. Remaining details for second pass, review with claude, start tests
            ii. Add pool management logic if necessary, review
            iii. Work on algorithm holdups (perhaps modifying spoofing), implement tests with top sort to investigate "virtual" reachability
            iv. Final work on algorithm holdups, test if algorithm finishes, temporarily abandon initial non-vanilla sort if necessary
            v. If still not working, abandon expanded contexts as well (and block system as a whole), get basic randomizations working
        3. Reflection
            i. Divide reflections based on priority/work needed, return to preprocessing as needed
            ii. Work on first half of reflections
            iii. Finish second half of reflections
            iv. Test for softlocks and fix issues; make bug list
        4. Balancing
            i. Add flow cost checks and updates within second-pass loop
            ii. Modify prereq loop so that many prereqs can be chosen at once, restrict randomizations done if needed (including recipe rando), try with hardcoding then abandon resource composition/complexity preservation if needed
            iii. Brainstorm other edge cases and implement checks
            iv. Implement any critical optimizations for fast enough loading, hardcode as needed, push as update 0.5.0
II. FEATURE: Duplicates, group unlocks (Into mid-February)
    A. Duplicates
        1. Prototype definitions
            i. Brainstorm duplicates needed, modify duplicates library as needed
            ii. Prototype definitions, custom graphics implementations, custom places in tech tree (with fallbacks for mods when techs don't exist, time permitting)
        2. (Move to later potentially) Testing impact of duplicates (goal to other planet)
            i. Start space age game, "more" on non-graph rando/no high chaos/default seed (no biters), high resources, get to small mall
            ii. Finish mall, automate green science, work toward oil
            iii. Research and find oil, begin processing, oil intermediates
            iv. Blue/gray science
            v. Rocket launch
            vi. Space science
            vii. Planet discovery for vulcanus, prep for trip
            viii. Arrival to vulcanus, reassess critical changes and impact of dupes
    B. Group unlocks
        1. Naive approach
            i. Brainstorm plan for group unlocks, consistent/bundled "story" randomization brainstorm
            ii. Generalize order finding pass, remove hardcoding, refactor
            iii. Add group unlock to prereq shuffle step (as needed)
            iv. Generalize duplicates, time-permitting, push 0.5.x
            v. Brainstorm future group unlock ideas
III. BRAINSTORM: Plan future "big plans" (Into March)
    A. Organization
        1. Compilation
            i. Move files/notes into central location
            ii. Summaries from ipad/notes app thoughts
        2. Planning
            i. Modify next steps as needed, plan future goals
            ii. Release plan, update mod description with dev plan (start dev logs if seems appropriate?)
    B. Algorithmic
        1. AND/OR semantics
            i. Think more about dual graph
            ii. Try out some ideas, outline issues/potential solutions in document
        2. Isolatability
            i. Brainstorm ways to improve
            ii. Generalize context for use in future games
        3. Blockification
            i. Generalize approach, brainstorm ways to remove more difficult to remove blocks (test)
        4. Optimization
            i. Create initial optimization plans, very brief, focused on big Oh improvements (okay if no major improvements found)
        5. Removal of hardcoding
            i. Think about how to remove hardcoding
            ii. Scour code and make list of hardcoding places, compile
    C. Randomizations
        1. Master list
            i. Write master list of all possible randos, categorize
            ii. Write approaches/creative possibilities using API for some
        2. API scouring
            i. Go through API for any other properties (add semantics to numerical values, references, tables, list source properties for each, go through via python code rather than ad hoc)
            ii. Review list and create document reviewing randomized (split into gamplay changing or silly)/to be randomized/potential/not planned, add "spoofed" properties, descriptions
IV. IMPROVEMENT: Numerical rando improvement, second pass through graph rando (Most of spring quarter)
    A. Non-graph rando (frequent 0.5.x updates)
        1. Review/overhaul
            i. Review current numerical randomizations, adjust parameters, look into hard limits, nil checks/compat/assumption removal, fix up tooltips, adjust recently created API rando list, split into parts by randomization (current guess for four parts), reorganize files as necessary (split entities file?)
            ii. Rewrite relevant libraries as needed
            iii. Part one of numerical randomizations overhaul (entities part one?)
            iv. Part two of numerical randomizations overhauls (entities part two?)
            v. Part three of numerical randomizations (items/triggers)
            vi Part four of numerical randomizations (the rest)
        2. Misc. randos
            i. Re-organize, fix up any parts not satisfied with, refactoring
            ii. Limits/chaos integration, plan for future implementations
            iii. Add one new misc. rando brainstormed (time permitting)
        3. Military/sensitive randomizations
            i. Note sensitive randos, separate out into new setting, brainstorm ways to address balancing
    B. Graph-based rando foundations (less? frequent 0.5.x updates)
        1. Distill current algorithms, bottom-up
            i. Document/cleanup fundamental libraries (graph-util, etc.)
            ii. Document/clean up lookups, start on optimization
            iii. Finish optimizing lookups, start on documenting/cleaning up logic graph
            iv. Finish documenting/clean up logic graph, add/optimize nodes if there's extra time
            v. Document/clean up top sort algo, write pseudocode for most complex version, plus "for dummies" guide for implementing top sorts
            vi. Rewrite top sort with optimization/simplicity/clarity in mind
            vii. Rework flow cost, switch completely over to new libraries, work on not raw resource auto-sensing if not already implemented
            viii. Document/clean up first-pass rando, fix any critical issues, note core issues
            ix. Document/clean up prereq shuffle second-pass, describing arbitrary orderings property, playing around with prereq pool optimizations if deemed helpful
            x. Document/clean up handlers, generalize/abstract
        2. Core libraries
            i. Continued work refactoring/improving core libraries, focus on clarity and speed
            ii. Switch everything over to new libraries
        3. Flow cost improvements
            i. Coproduct aware cost split
            ii. Brainstorm more accurate yet efficient cost calculation algorithms, perhaps using precomputed values for vanilla/some mods?
            iii. Generalize main approach, patch some basic issues with specific solutions
        4. Top sort improvements
            i. Make top sort order impacted by seed (randomize dependent order), option for DFS; maybe there's more but I think that's all it would need at this point
        5. The big merge
            i. Merge new-lib and new logic in as the only library
    C. Unified rando rounding out sharp edges (if it succeeded, otherwise brainstorm other appraoches)
        1. Fixes
            i. Critical fixes discovered necessary
            ii. Finish critical fixes necessary
        2. Generalization
            i. Remove hardcoding from blockify, see if things still work
            ii. Refactor hardcoding needed to other files, compat logic
        3. Optimization
            i. Make a plan for changes that would most impact optimization (focus on long prereq-dependent loops perhaps?)
            ii. Code rewrite
            iii. Claude review and testing
            iv. Implementing fixes or declaring defeat for now
        4. Polish
            i. Go through and double check for any extra validation criteria
            ii. Add ways for chaos to factor in, some configuration for certain very important algorithm parameters if deemed useful enough
        5. Integration
            i. Time-permitting, try integrating old randos in, or at least updating them to new libraries as legacy choices
            ii. Upgrade unified rando infrastructure to support the item node separation needed for item rando
            iii. Quickly try implementing item rando in; give up for now if not working
    D. Reflection improvements
        1. Graphics
            i. Touch up graphics integrations for some randos, maybe ask for help in discord, make list of graphics changes that could improve the randomizer and document
            ii. Bugfixes for missing/switched graphics, or graphics that is "off"
        2. Localisation
            i. Fix localisation issues if present, move strings to localisation files, make friendlier for people wanting to translate?
            ii. Brainstorm methods for overcoming localisation string depth constraints, if present (tree balancer if applicable)
            iii. Implement localisation improvements if applicable
        3. "Left for later"
            i. Block one for improvements I didn't get time for initially
            i. Block two for improvements I didn't get time for initially
            i. Block three for improvements I didn't get time for initially
            i. Block four for improvements I didn't get time for initially
        4. Final touches
            i. Review any gathered issues, work on any critical for release, then update mod description/etc., release 0.6.0, celebrate
V. CONFIGURATION (LIMITED): Allow limited configuration from mod settings with focus on blacklists/etc. in case of bugs (0.6.x releases) (Last weeks of May/into June)
    A. User-side bug handling
        1. On/off abilities
            i. Ability to toggle individual parts of graph rando on/off
            ii. Ability to blacklist any/all mod items/recipes from all randos at once
            iii. Time permitting, allow rando-prototype specific toggling
        2. Logging
            i. Identify spots for better error messages, implement, test for edge cases and add warnings in those cases (to be printed on game start)
            ii. Identify spots where info would be helpful, allow setting logging levels in mod settings, look into putting info files into script-output with settings on
            iii. Remove unconditional logging throughout code, condition on logging levels
    B. Limited customization
        1. Explicit value setting
            i. Allow explicit value setting for anything in the randomization (not user-friendly yet)
            ii. Document briefly in README, add reference values
        2. Parameter modification
            i. Allow limited changing of graph parameters (ability to test if some other parameters work for other modpacks etc.)
            ii. Limited seed search; put in number of attempts and potentially even conditions for acceptance (though not user-friendly yet)
            iii. Brainstorm and leave TODO for future customization
VI. COMPATIBILITY (LIMITED): Start some QOL mod support (0.6.x releases) (Done by summer)
    A. Initial pass
        1. Already reported
            i. Fix broken interactions reported anytime 0.4.0 onward, if still present
            ii. Second time block for fixing, leave any fixes not gotten to for later
        2. Most popular
            i. Try out randomizer + other mod, where other mod is QOL mod chosen from the portal one by one in descending order of total downloads (filtering out some at my discretion), making list of incompatibilities
            ii. Continue fixing incompatibilities as I go, create list of notable bugs I couldn't fix, put somewhere (maybe mod description)
        3. Most useful
            i. Brainstorm/ask about what mods are used for this most (helmod/factory planner, extended descriptions, recipe book?), check compat with each
            ii. Time spent fixing any incompatibilities with those
    B. Complex interactions
        1. "Worst" settings
            i. Compile list of explicitly compatible (so far) mods, try each with "most" randomized settings, note errors
            ii. Work through errors, going from most important down (most useful mods)
            iii. Continue working through errors, maybe forming general patterns to increase compatibility, document settings that still don't work with certain mods
        2. Combined
            i. Enable all mods at once, see what settings they break on if any, work through errors
        3. Different seeds
            i. Using default settings, iterate through many seeds (using previous seed search/logging/warnings perhaps), note difficulties, work through bugs
            ii. Continue identifying issues, working through bugs, note any I didn't get to for later
VII. COMPLETENESS: Crazy features and height of the mod's power, hopefully (start calling 0.7.x) (Half of summer)
    A. Plan
        1. Longterm
            i. Re-evaluate longterm plans for rando, list core features, add necessary steps by end and nice-to-haves
            ii. Set expected dates, current issues and priorities list, make announcements about plans
        2. Features
            i. Missing feature list, ranked (don't focus on specific randomizations), list somewhere with general strategy, especially ones I may not get to in case a later person does them
            ii. Add to this plan as needed with features, then start listing numerical/other randos I'd be interested in, gather community input
            iii. Compile complete list, also create handlers list for unified rando (if it worked), focus on things that would help later planet mixing
            iv. Compile new nodes list, too (three priority groups), allow node "splitting" like in item rando if results prove helpful
    B. New randomizations (last planned round of large randomizer additions), (frequent 0.7.x releases)
        1. Numerical/property randomizations
            i. First round for numerical/property randomizations
            ii. Second round for numerical/property randomizations
            iii. Third round for numerical/property randomizations
            iv. Fourth round for numerical/property randomizations
        2. Misc. non-graph randomizations (four-ish? Might grow, but if so might have to leave some for down the road)
            i. First slot for numerical/property randomizations
            ii. Second slot for numerical/property randomizations
            iii. Third slot for numerical/property randomizations
            iv. Fourth slot for numerical/property randomizations
        3. Node overhaul
            i. Priority group one for new nodes
            ii. Priority group two for new nodes
            iii. Priority group three for new nodes
            iv. Fix anything broken with node splitting, handle with blockification if necessary/possible
        4. Item rando (part 2)
            i. Finish extending unified to handle item rando (if not already handled)
            ii. Finish up extension, hopefully satisfactory enough to delete/replace old item rando completely (if still around), brainstorm/plan new randos using item rando capabilities
            iii. Implement first new idea
            iv. Implement second new idea
            v. Implement third new idea (if applicable), leave further ideas for later
        5. Unified handlers (I really hope unified pans out like this)
            i. Split up new handlers work, create task list, plan out approach, write skeletons
            ii. Fill in skeletons with tons of comments, do gathering functions for all
            iii. Complete validation functions
            iv. Reflection functions part 1
            v. Reflection functions part 2
            vi. Slot to work on algorithmic changes needed to accommodate any of the new handlers
    C. Crazy (save for 0.8.0 release)
        1. Dupe graphics
            i. Get more dupe graphics (ask around maybe), or decided on way to automate duping pipeline (fallback to numbers)
            ii. Dupe graphics for planets
            iii. Options for increased dupes, especially for previously non-duped things like graphics
        2. Planetary mixing
            i. Duplicate planets, test consequences
            ii. Slot for bugfixes, gathering results, assessing if it worked
            iii. Coming up with plan for getting quickly to usable state, or admitting defeat
            iv. Last efforts on this for now (maybe finish another time)
        3. Watch the world burn
            i. Brainstorm/recompile changes for this mode, expectations/descriptions, get excited for it
            ii. Watch the world burn special changes file writing
            iii. Special behavior for handlers on watch the world burn if warranted for that handler (okay to do hardcoding)
            iv. Finish handler special behavior, look for potential special behavior for any other randomizations/numerical etc.
            v. Last touches, like jumbled localisations of planets and pasting burning ring of fire code in from fun mode
            vi. Secret configuration strings for enabling/disabling any single parts of watch the world burn
    D. Celebrate 0.8.0 release!
VIII. POLISH: Second round of optimizations, improvements, documentation, etc. (Rest of summer, minus playthrough, which would be good chunk of fall quarter)
    A. Optimization (because I'm sure it'll be slow by now)
        1. Profiling
            i. Add profiling logging, track slowest parts, make targets for reduction (time for three tries, if more needed then people will have to just live with slowness for a while)
        2. Implementation
            i. Implement speedup, review, test for speedup, test for correctness
            ii. Rinse and repeat last step
            iii. Rinse and repeat one last time
        3. Graph performance
            i. Be more aggressive about cutting off nodes, account for this in randomizations, consider removal of slots
            ii. Existence of some nodes depends on randomizations checked, low node mode
    B. Documentation
        1. Writeups
            i. Make sure they're moved to the randomizer git, maybe make mod a subfolder of the git/reorganize? Idk decide then, this is in a while, plan out what else to write, rewrirte top sort doc
            ii. Finish prereq shuffle doc, with modifications needed that I'd have learned throughout this whole process
            iii. Document mod structure/terminology specific to the factorio randomizer/etc. in a latex file
            iv. Include references to documents within the code, along with simpler example randomizations
        2. Entry points
            i. Give example plan in README to someone wanting to learn more about the project (read this, then X), include modifications they could try/things to play around with
            ii. Make list of "good first issues", reorganize github
            iii. Document possible next steps (focusing on things I probably won't end up doing, for those who want to try it out)
            iv. Make baby versions of different functions/randomizations (abandon if too time-consuming)
            v. Try teaching claude/another person/etc. and noticing where it thinks more detail is needed
        3. Standardization
            i. Refactor/reorganize, make file hierarchy and naming more standard (get feedback for how to do)
            ii. Remove globals
            iii. Get feedback on approachability of repo?
        4. Publicity
            i. Rewrite README, finish organizing github repo
            ii. Rewrite mod page, new pictures, reorganize my discord, especially pins in randomizer channel
    C. Configuration
        1. In-game tool
            i. Plan out in-game UI, draw picture of what it should look like
            ii. Code prototype version, include text and tabs for different purposes (info, config design, and warnings should be main ones)
            iii. Create config groups, decide values that should be changeable or only for advanced, start implementing in UI
            iv. Finish implementing UI and make string encoder/decoder for values
    D. Compatibility (these will likely all fail at first, but will get us closer to our dreams)
        1. Space Exploration
            i. Try loading with SE, note initial errors, try to get to load
            ii. Finish attempting to successfully load, brainstorm any graph changes needed, note any things that seem off, begin fixes
            iii. Finish compatibility fixes, note potential compatibility, but also that it hasn't been fully tested
        2. Planet mods
            i. Try with various planet mods, note ones that seem like good fits, attempt fixes
            ii. Ask for input on potential gotchas I might need to code into dependency graph or account for in randomization
            iii. Try extending planet duplication settings etc. to planet mods
        3. Pyanodons
            i. Try it out, see what main issue is (loading speed?), maybe if speed then let it load for a day just to test? Or randomize outside factorio?
            ii. Do simplex for costs or other methods if costs aren't calculated well
            iii. Also finish modifications to graph needed for pyanodons (ask around if any others needed, especially autotech people)
            iv. Extra block to try out fluid temperatures too if things are somehow going well
    E. Important catch-up block
        1. Block to insert important things I need to return to (only most important)
        2. Est. 20 hours here?
    F. Full Playthrough with space age
        1. Est. 50 hours here? Maybe longer oop...
    G. Tweaks
        1. Tweaks/adjustments noted from playthrough, also note overall feel
        2. Release 0.9.0
IX. FINALIZATION: Last major features (Finish up, plan to release on 28th birthday?)
    A. This is intentionally left blank for adding any new features I feel would be needed after the full playthrough
    B. Est. 50 hours
    C. Gather "testers" (most feedback won't matter at this point I guess, but good to have anyways), say it's ready in doshcord (if dosh is still around)... and, yeah, I guess that's it
    D. Release 1.0.0, celebrate (plan special occasion?)
X. MAINTENANCE: Any last bugs, continued features I want to return to, etc.
    A. Plan approx. 10-20 hours post release for fixes?
    
Note: If unified rando doesn't work, I'll have to redo a lot of this to think of another way to fit everything in
We should at least be able to do a simpler version, though, right? As long as it's simultaneous

Not included:
 * Recoding "proper" recipe rando (I might have to settle but at least I know I can do it; there's always vill's anyways)